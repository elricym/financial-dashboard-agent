# 06 - å‰ç«¯æ¸²æŸ“å±‚

## æ¶æ„æ¦‚è¿°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      App Shell                                â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Chat Panel    â”‚  â”‚        Dashboard Canvas            â”‚  â”‚
â”‚  â”‚                â”‚  â”‚                                    â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚ Message    â”‚â”‚  â”‚  â”‚      GridStack Layout        â”‚  â”‚  â”‚
â”‚  â”‚  â”‚ List       â”‚â”‚  â”‚  â”‚                              â”‚  â”‚  â”‚
â”‚  â”‚  â”‚            â”‚â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚            â”‚â”‚  â”‚  â”‚  â”‚PanelWrap â”‚ â”‚PanelWrap â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚            â”‚â”‚  â”‚  â”‚  â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚            â”‚â”‚  â”‚  â”‚  â”‚â”‚LWChart â”‚â”‚ â”‚â”‚ECharts â”‚â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚            â”‚â”‚  â”‚  â”‚  â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚            â”‚â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚            â”‚â”‚  â”‚  â”‚                              â”‚  â”‚  â”‚
â”‚  â”‚  â”‚            â”‚â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚            â”‚â”‚  â”‚  â”‚  â”‚PanelWrap â”‚ â”‚PanelWrap â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚            â”‚â”‚  â”‚  â”‚  â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚            â”‚â”‚  â”‚  â”‚  â”‚â”‚Custom  â”‚â”‚ â”‚â”‚LWChart â”‚â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚            â”‚â”‚  â”‚  â”‚  â”‚â”‚Feed    â”‚â”‚ â”‚â”‚        â”‚â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚  â”‚  â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚ Input Box  â”‚â”‚  â”‚  â”‚                              â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ Dashboard Tabs: [é»„é‡‘åˆ†æ] [åŠ å¯†è´§å¸] [+æ–°å»º]             â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## æ¸²æŸ“æµç¨‹ï¼šCode â†’ Data â†’ UI

åç«¯è´Ÿè´£æ‰§è¡Œ panel.code å¹¶å°†æ•°æ®æ¨é€ç»™å‰ç«¯ã€‚å‰ç«¯ä¸ç›´æ¥æ‰§è¡Œ codeã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        æ¸²æŸ“æµç¨‹                                   â”‚
â”‚                                                                 â”‚
â”‚  state.json (å« panel.code)                                      â”‚
â”‚       â”‚                                                         â”‚
â”‚       â–¼                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚  â”‚  åç«¯ Code Executor          â”‚                                â”‚
â”‚  â”‚  for each panel:            â”‚                                â”‚
â”‚  â”‚    sandbox.execute(panel.code)                               â”‚
â”‚  â”‚    â†’ data                   â”‚                                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚             â”‚                                                   â”‚
â”‚             â–¼                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚  â”‚  WebSocket æ¨é€              â”‚                                â”‚
â”‚  â”‚  { panels: [                â”‚                                â”‚
â”‚  â”‚    { id, title, type,       â”‚                                â”‚
â”‚  â”‚      renderer, data, ... }  â”‚   â† data ç”±åç«¯æ‰§è¡Œ code æ³¨å…¥    â”‚
â”‚  â”‚  ]}                         â”‚                                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚             â”‚                                                   â”‚
â”‚             â–¼                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚  â”‚  å‰ç«¯æ¸²æŸ“                    â”‚                                â”‚
â”‚  â”‚  PanelWrapper â†’ Renderer    â”‚                                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**åˆ·æ–° = é‡æ–°æ‰§è¡Œ codeï¼Œæ— éœ€ Agentï¼š**
```
ç”¨æˆ·ç‚¹å‡»åˆ·æ–° â†’ åç«¯é‡æ–°æ‰§è¡Œ panel.code â†’ æ–° data â†’ WebSocket æ¨é€ â†’ å‰ç«¯æ›´æ–°
```

### åç«¯ Code Executor

```go
type CodeExecutor struct {
    sandboxPool *SandboxPool
    adapters    *CachedAdapterRegistry
}

// ExecuteAllPanels æ‰§è¡Œæ‰€æœ‰ panel çš„ codeï¼Œè¿”å›å¸¦ data çš„æ¸²æŸ“æ•°æ®
func (e *CodeExecutor) ExecuteAllPanels(ctx context.Context, state *DashboardState) ([]PanelRenderData, error) {
    results := make([]PanelRenderData, len(state.Panels))
    
    var wg sync.WaitGroup
    for i, panel := range state.Panels {
        wg.Add(1)
        go func(idx int, p Panel) {
            defer wg.Done()
            
            sandbox := e.sandboxPool.Get()
            defer e.sandboxPool.Put(sandbox)
            
            sandbox.Inject("sdk", e.adapters)
            sandbox.Inject("utils", standardUtils)
            
            data, err := sandbox.Execute(ctx, p.Code)
            
            results[idx] = PanelRenderData{
                ID:         p.ID,
                Title:      p.Title,
                Type:       p.Type,
                Renderer:   p.Renderer,
                Position:   p.Position,
                Data:       data,
                Indicators: p.Indicators,
                Config:     p.Config,
                Error:      errStr(err),
            }
        }(i, panel)
    }
    wg.Wait()
    
    return results, nil
}

type PanelRenderData struct {
    ID         string         `json:"id"`
    Title      string         `json:"title"`
    Type       PanelType      `json:"type"`
    Renderer   RendererType   `json:"renderer"`
    Position   *Position      `json:"position,omitempty"`
    Data       any            `json:"data"`
    Indicators []Indicator    `json:"indicators,omitempty"`
    Config     map[string]any `json:"config,omitempty"`
    Error      string         `json:"error,omitempty"`
}
```

## ç»„ä»¶æ ‘

```
App
â”œâ”€â”€ DashboardTabs              // å¤šçœ‹æ¿åˆ‡æ¢
â”œâ”€â”€ ChatPanel                  // å·¦ä¾§å¯¹è¯é¢æ¿
â”‚   â”œâ”€â”€ MessageList
â”‚   â”‚   â”œâ”€â”€ UserMessage
â”‚   â”‚   â”œâ”€â”€ AgentMessage
â”‚   â”‚   â””â”€â”€ StatusMessage      // "æ­£åœ¨ç”Ÿæˆçœ‹æ¿..." ç­‰çŠ¶æ€
â”‚   â””â”€â”€ ChatInput
â””â”€â”€ DashboardCanvas            // å³ä¾§çœ‹æ¿ç”»å¸ƒ
    â””â”€â”€ GridLayout             // gridstack.js åŒ…è£…
        â””â”€â”€ PanelWrapper[]     // æ¯ä¸ª panel çš„å®¹å™¨
            â”œâ”€â”€ PanelHeader    // æ ‡é¢˜ã€æ“ä½œæŒ‰é’®ï¼ˆå«åˆ·æ–°æŒ‰é’®ï¼‰
            â”œâ”€â”€ PanelContent   // æ ¹æ® renderer åˆ†å‘
            â”‚   â”œâ”€â”€ LWChartPanel
            â”‚   â”œâ”€â”€ EChartsPanel
            â”‚   â””â”€â”€ CustomPanel
            â”‚       â”œâ”€â”€ FeedPanel
            â”‚       â”œâ”€â”€ TablePanel
            â”‚       â””â”€â”€ MetricCardPanel
            â””â”€â”€ PanelFooter    // æ•°æ®æ¥æºã€åˆ·æ–°æ—¶é—´
```

## WebSocket é€šä¿¡

### è¿æ¥ç®¡ç†

```typescript
class DashboardSocket {
  private ws: WebSocket;
  private handlers: Map<string, Function[]> = new Map();
  
  connect(sessionId: string) {
    this.ws = new WebSocket(`/ws?session=${sessionId}`);
    
    this.ws.onmessage = (event) => {
      const msg: WSMessage = JSON.parse(event.data);
      this.emit(msg.type, msg.payload);
    };
  }
  
  on(type: string, handler: Function) {
    if (!this.handlers.has(type)) this.handlers.set(type, []);
    this.handlers.get(type)!.push(handler);
  }
}
```

### æ¶ˆæ¯ç±»å‹

```typescript
type WSMessage =
  | { type: 'dashboard:created'; payload: { dashboardId: string; panels: PanelRenderData[] } }
  | { type: 'dashboard:updated'; payload: { dashboardId: string; diff: StateDiff; panels: PanelRenderData[] } }
  | { type: 'dashboard:deleted'; payload: { dashboardId: string } }
  | { type: 'agent:thinking';    payload: { message: string } }
  | { type: 'agent:executing';   payload: { tool: string; code?: string } }
  | { type: 'agent:message';     payload: { text: string } }
  | { type: 'panel:refreshed';   payload: { dashboardId: string; panelId: string; data: any } }
  | { type: 'error';             payload: { message: string; code?: string } }
```

### å‰ç«¯çŠ¶æ€æ›´æ–°

```typescript
// å‰ç«¯ store å­˜å‚¨çš„æ˜¯å¸¦ data çš„æ¸²æŸ“æ•°æ®ï¼Œä¸æ˜¯ code
interface DashboardStore {
  dashboards: Map<string, DashboardRenderState>;
  activeDashboardId: string | null;
  
  applyUpdate(dashboardId: string, panels: PanelRenderData[]): void;
  refreshPanel(dashboardId: string, panelId: string): void;
  setActive(dashboardId: string): void;
}

// åˆ·æ–°å•ä¸ª panel â€” è°ƒç”¨åç«¯ APIï¼Œåç«¯é‡æ–°æ‰§è¡Œ panel.code
async function refreshPanel(dashboardId: string, panelId: string) {
  const res = await fetch(`/api/dashboard/${dashboardId}/panel/${panelId}/refresh`, {
    method: 'POST',
  });
  // æ–°æ•°æ®é€šè¿‡ WebSocket panel:refreshed æ¨é€
}

// åˆ·æ–°æ•´ä¸ªçœ‹æ¿
async function refreshDashboard(dashboardId: string) {
  const res = await fetch(`/api/dashboard/${dashboardId}/refresh`, {
    method: 'POST',
  });
  // æ‰€æœ‰ panel çš„æ–°æ•°æ®é€šè¿‡ WebSocket æ¨é€
}
```

## æ¸²æŸ“å™¨å®ç°

### PanelWrapper åˆ†å‘

```tsx
function PanelContent({ panel }: { panel: PanelRenderData }) {
  if (panel.error) {
    return <PanelError error={panel.error} panelId={panel.id} />;
  }
  
  switch (panel.renderer) {
    case 'lightweight-charts':
      return <LWChartPanel panel={panel} />;
    case 'echarts':
      return <EChartsPanel panel={panel} />;
    case 'custom':
      return <CustomPanelRouter panel={panel} />;
    default:
      return <div>Unsupported renderer: {panel.renderer}</div>;
  }
}

function CustomPanelRouter({ panel }: { panel: PanelRenderData }) {
  switch (panel.type) {
    case 'feed':        return <FeedPanel panel={panel} />;
    case 'table':       return <TablePanel panel={panel} />;
    case 'metric_card': return <MetricCardPanel panel={panel} />;
    default:            return <GenericCustomPanel panel={panel} />;
  }
}
```

### Lightweight Charts Panel

```tsx
import { createChart, IChartApi, ISeriesApi } from 'lightweight-charts';

function LWChartPanel({ panel }: { panel: PanelRenderData }) {
  const containerRef = useRef<HTMLDivElement>(null);
  const chartRef = useRef<IChartApi | null>(null);
  const seriesRef = useRef<ISeriesApi<any> | null>(null);
  
  useEffect(() => {
    if (!containerRef.current) return;
    
    const chart = createChart(containerRef.current, {
      layout: {
        background: { color: '#1a1a2e' },
        textColor: '#e0e0e0',
      },
      grid: {
        vertLines: { color: '#2a2a3e' },
        horzLines: { color: '#2a2a3e' },
      },
      timeScale: { timeVisible: true },
      crosshair: { mode: 0 },
    });
    
    let series: ISeriesApi<any>;
    switch (panel.type) {
      case 'candlestick':
        series = chart.addCandlestickSeries({
          upColor: '#26a69a',
          downColor: '#ef5350',
          borderVisible: false,
          wickUpColor: '#26a69a',
          wickDownColor: '#ef5350',
        });
        break;
      case 'line':
        series = chart.addLineSeries({ color: '#2196F3', lineWidth: 2 });
        break;
      case 'area':
        series = chart.addAreaSeries({
          topColor: 'rgba(33, 150, 243, 0.4)',
          bottomColor: 'rgba(33, 150, 243, 0.0)',
          lineColor: '#2196F3',
        });
        break;
    }
    
    series.setData(panel.data);
    
    if (panel.indicators) {
      for (const ind of panel.indicators) {
        addIndicatorToChart(chart, series, panel.data, ind);
      }
    }
    
    chart.timeScale().fitContent();
    chartRef.current = chart;
    seriesRef.current = series;
    
    const ro = new ResizeObserver(() => {
      chart.applyOptions({
        width: containerRef.current!.clientWidth,
        height: containerRef.current!.clientHeight,
      });
    });
    ro.observe(containerRef.current);
    
    return () => { ro.disconnect(); chart.remove(); };
  }, []);
  
  useEffect(() => {
    if (seriesRef.current && panel.data) {
      seriesRef.current.setData(panel.data);
    }
  }, [panel.data]);
  
  return <div ref={containerRef} style={{ width: '100%', height: '100%' }} />;
}
```

### æŠ€æœ¯æŒ‡æ ‡å åŠ 

```typescript
function addIndicatorToChart(
  chart: IChartApi,
  mainSeries: ISeriesApi<any>,
  ohlcvData: any[],
  indicator: Indicator
) {
  const closes = ohlcvData.map(d => d.close || d.value);
  const times = ohlcvData.map(d => d.time);
  
  switch (indicator.type) {
    case 'MA':
    case 'SMA': {
      const periods = indicator.periods || [indicator.period!];
      const colors = ['#FF9800', '#9C27B0', '#00BCD4', '#E91E63'];
      periods.forEach((period, i) => {
        const ma = computeMA(closes, period);
        const lineSeries = chart.addLineSeries({
          color: colors[i % colors.length],
          lineWidth: 1,
          priceLineVisible: false,
        });
        lineSeries.setData(
          ma.map((v, idx) => ({ time: times[idx], value: v })).filter(d => d.value !== null)
        );
      });
      break;
    }
    
    case 'BOLL': {
      const period = indicator.period || 20;
      const stdDev = indicator.params?.stdDev || 2;
      const { upper, middle, lower } = computeBOLL(closes, period, stdDev);
      
      chart.addLineSeries({ color: 'rgba(255,152,0,0.5)', lineWidth: 1, priceLineVisible: false })
        .setData(upper.map((v, i) => ({ time: times[i], value: v })).filter(d => d.value !== null));
      chart.addLineSeries({ color: 'rgba(255,152,0,0.8)', lineWidth: 1, priceLineVisible: false })
        .setData(middle.map((v, i) => ({ time: times[i], value: v })).filter(d => d.value !== null));
      chart.addLineSeries({ color: 'rgba(255,152,0,0.5)', lineWidth: 1, priceLineVisible: false })
        .setData(lower.map((v, i) => ({ time: times[i], value: v })).filter(d => d.value !== null));
      break;
    }
    
    case 'RSI': {
      const period = indicator.period || 14;
      const rsi = computeRSI(closes, period);
      const rsiSeries = chart.addLineSeries({
        color: '#E040FB',
        lineWidth: 1,
        priceLineVisible: false,
        priceScaleId: 'rsi',
      });
      rsiSeries.setData(
        rsi.map((v, i) => ({ time: times[i], value: v })).filter(d => d.value !== null)
      );
      chart.priceScale('rsi').applyOptions({
        scaleMargins: { top: 0.8, bottom: 0 },
      });
      break;
    }
  }
}
```

### ECharts Panel

```tsx
import * as echarts from 'echarts';

function EChartsPanel({ panel }: { panel: PanelRenderData }) {
  const containerRef = useRef<HTMLDivElement>(null);
  const chartRef = useRef<echarts.ECharts | null>(null);
  
  useEffect(() => {
    if (!containerRef.current) return;
    
    const chart = echarts.init(containerRef.current, 'dark');
    const option = buildEChartsOption(panel);
    chart.setOption(option);
    chartRef.current = chart;
    
    const ro = new ResizeObserver(() => chart.resize());
    ro.observe(containerRef.current);
    
    return () => { ro.disconnect(); chart.dispose(); };
  }, []);
  
  useEffect(() => {
    if (chartRef.current) {
      chartRef.current.setOption(buildEChartsOption(panel), true);
    }
  }, [panel.data, panel.config]);
  
  return <div ref={containerRef} style={{ width: '100%', height: '100%' }} />;
}

function buildEChartsOption(panel: PanelRenderData): echarts.EChartsOption {
  switch (panel.type) {
    case 'heatmap':  return buildHeatmapOption(panel);
    case 'pie':      return buildPieOption(panel);
    case 'radar':    return buildRadarOption(panel);
    case 'bar':      return buildBarOption(panel);
    case 'scatter':  return buildScatterOption(panel);
    case 'treemap':  return buildTreemapOption(panel);
    case 'sankey':   return buildSankeyOption(panel);
    default:         return {};
  }
}

function buildHeatmapOption(panel: PanelRenderData): echarts.EChartsOption {
  const { xLabels, yLabels, values } = panel.data;
  const data: number[][] = [];
  values.forEach((row: number[], i: number) => {
    row.forEach((val: number, j: number) => {
      data.push([j, i, val]);
    });
  });
  
  return {
    tooltip: { position: 'top' },
    grid: { top: 40, bottom: 40, left: 80, right: 40 },
    xAxis: { type: 'category', data: xLabels, splitArea: { show: true } },
    yAxis: { type: 'category', data: yLabels, splitArea: { show: true } },
    visualMap: {
      min: -1, max: 1,
      calculable: true,
      orient: 'horizontal',
      left: 'center',
      bottom: 0,
      inRange: {
        color: panel.config?.colorScale === 'RdYlGn'
          ? ['#d73027', '#fee08b', '#1a9850']
          : ['#313695', '#ffffbf', '#a50026']
      }
    },
    series: [{
      type: 'heatmap',
      data,
      label: { show: true, formatter: (p: any) => p.data[2].toFixed(2) },
    }]
  };
}
```

### Feed Panel

```tsx
function FeedPanel({ panel }: { panel: PanelRenderData }) {
  const { items } = panel.data;
  const config = panel.config || {};
  
  const sortedItems = useMemo(() => {
    let sorted = [...items];
    switch (config.sortBy) {
      case 'engagement':
        sorted.sort((a, b) => (b.metrics?.likes || 0) - (a.metrics?.likes || 0));
        break;
      case 'sentiment':
        sorted.sort((a, b) => (b.sentimentScore || 0) - (a.sentimentScore || 0));
        break;
      case 'time':
      default:
        sorted.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
    }
    return sorted;
  }, [items, config.sortBy]);
  
  return (
    <div className="feed-panel">
      {sortedItems.map(item => (
        <FeedItem key={item.id} item={item} showSentiment={config.showSentiment} />
      ))}
    </div>
  );
}

function FeedItem({ item, showSentiment }: { item: any; showSentiment?: boolean }) {
  return (
    <div className={`feed-item ${item.sentiment}`}>
      <div className="feed-item-header">
        <span className="author">{item.author?.name || item.source}</span>
        <span className="time">{formatRelativeTime(item.timestamp)}</span>
        {showSentiment && (
          <span className={`sentiment-badge ${item.sentiment}`}>
            {item.sentiment === 'positive' ? 'ğŸŸ¢' : item.sentiment === 'negative' ? 'ğŸ”´' : 'âšª'}
            {item.sentimentScore?.toFixed(2)}
          </span>
        )}
      </div>
      <div className="feed-item-body">{item.text || item.title}</div>
      {item.metrics && (
        <div className="feed-item-metrics">
          {item.metrics.likes && <span>â¤ï¸ {formatNumber(item.metrics.likes)}</span>}
          {item.metrics.retweets && <span>ğŸ”„ {formatNumber(item.metrics.retweets)}</span>}
        </div>
      )}
    </div>
  );
}
```

### MetricCard Panel

```tsx
function MetricCardPanel({ panel }: { panel: PanelRenderData }) {
  const { value, label, unit, change, changePercent, direction, sparkline, subtitle } = panel.data;
  
  return (
    <div className="metric-card">
      <div className="metric-label">{label}</div>
      <div className="metric-value">
        {formatNumber(value)} <span className="metric-unit">{unit}</span>
      </div>
      <div className={`metric-change ${direction}`}>
        {direction === 'up' ? 'â–²' : 'â–¼'} {formatNumber(Math.abs(change))} ({(changePercent * 100).toFixed(2)}%)
      </div>
      {sparkline && (
        <div className="metric-sparkline">
          <Sparkline data={sparkline} color={direction === 'up' ? '#26a69a' : '#ef5350'} />
        </div>
      )}
      {subtitle && <div className="metric-subtitle">{subtitle}</div>}
    </div>
  );
}
```

## GridStack å¸ƒå±€

```tsx
import { GridStack } from 'gridstack';
import 'gridstack/dist/gridstack.min.css';

function GridLayout({ panels, layout }: { panels: PanelRenderData[]; layout: LayoutConfig }) {
  const gridRef = useRef<HTMLDivElement>(null);
  const gsRef = useRef<GridStack | null>(null);
  
  useEffect(() => {
    if (!gridRef.current) return;
    
    gsRef.current = GridStack.init({
      column: layout.columns,
      cellHeight: 300,
      margin: layout.gap || 8,
      animate: true,
      float: layout.mode === 'freeform',
    }, gridRef.current);
    
    return () => gsRef.current?.destroy(false);
  }, []);
  
  return (
    <div ref={gridRef} className="grid-stack">
      {panels.map(panel => (
        <div
          key={panel.id}
          className="grid-stack-item"
          gs-x={panel.position?.col || 0}
          gs-y={panel.position?.row || 0}
          gs-w={panel.position?.colSpan || 1}
          gs-h={panel.position?.rowSpan || 1}
        >
          <div className="grid-stack-item-content">
            <PanelWrapper panel={panel} />
          </div>
        </div>
      ))}
    </div>
  );
}
```

## Agent çŠ¶æ€åé¦ˆ

```tsx
function AgentStatus({ status }: { status: AgentStatusMessage | null }) {
  if (!status) return null;
  
  return (
    <div className="agent-status">
      <Spinner size="small" />
      <span>
        {status.type === 'thinking' && 'æ€è€ƒä¸­...'}
        {status.type === 'searching' && 'æœç´¢æ•°æ®æº...'}
        {status.type === 'executing' && 'ç”Ÿæˆçœ‹æ¿...'}
        {status.type === 'mutating' && 'æ›´æ–°çœ‹æ¿...'}
        {status.type === 'validating' && 'éªŒè¯æ•°æ®è·å–ä»£ç ...'}
      </span>
      {status.detail && <span className="status-detail">{status.detail}</span>}
    </div>
  );
}
```

## ä¸»é¢˜

```css
:root {
  /* Dark theme (default) */
  --bg-primary: #0d1117;
  --bg-secondary: #161b22;
  --bg-panel: #1a1f2e;
  --border: #30363d;
  --text-primary: #e6edf3;
  --text-secondary: #8b949e;
  --accent: #58a6ff;
  --positive: #26a69a;
  --negative: #ef5350;
}
```
